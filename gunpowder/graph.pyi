# flake8: noqa
from __future__ import annotations

from typing import Any, Dict, Iterator, NoReturn, Optional, Set, Union

import networkx as nx
import numpy as np

from .freezable import Freezable
from .graph_spec import GraphSpec
from .roi import Roi


class Node(Freezable):
    """A stucture representing each node in a Graph."""

    def __init__(
        self,
        id: int,
        location: np.ndarray,
        temporary: bool = False,
        attrs: Optional[Dict[str, Any]] = None,
    ): ...
    @property
    def location(self) -> np.ndarray: ...
    @location.setter
    def location(self, new_location: np.ndarray) -> None: ...
    @property
    def id(self) -> int: ...
    @property
    def original_id(self) -> Optional[int]: ...
    @property
    def temporary(self) -> bool: ...
    @property
    def attrs(self) -> Dict[str, Any]: ...
    @property
    def all(self) -> Dict[str, Any]: ...
    @classmethod
    def from_attrs(cls, attrs: Dict[str, Any]) -> Node: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

class Edge(Freezable):
    """A structure representing edges in a graph."""

    def __init__(
        self, u: int, v: int, attrs: Optional[Dict[str, Any]] = None
    ) -> None: ...
    @property
    def u(self) -> int: ...
    @property
    def v(self) -> int: ...
    @property
    def all(self) -> Dict[str, Any]: ...
    def __iter__(self) -> Iterator[int]: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def directed_eq(self, other: Any) -> bool: ...
    def undirected_eq(self, other: Any) -> bool: ...

class Graph(Freezable):
    """A structure containing a list of :class:`Node`, a list of :class:`Edge`,
    and a specification describing the data."""

    __graph: nx.Graph

    def __init__(
        self, nodes: Iterator[Node], edges: Iterator[Edge], spec: GraphSpec
    ) -> None: ...
    @property
    def spec(self) -> GraphSpec: ...
    @spec.setter
    def spec(self, new_spec: GraphSpec) -> None: ...
    @property
    def directed(self) -> bool: ...
    def create_graph(
        self, nodes: Iterator[Node], edges: Iterator[Edge]
    ) -> nx.Graph: ...
    @property
    def nodes(self) -> Iterator[Node]: ...
    def num_vertices(self) -> int: ...
    def num_edges(self) -> int: ...
    @property
    def edges(self) -> Iterator[Edge]: ...
    def neighbors(self, node: Node) -> Iterator[Node]: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def node(self, id: int) -> Node:
        """Get node with a specific id"""
    def contains(self, node_id: int) -> bool: ...
    def remove_node(self, node: Node, retain_connectivity: bool = False) -> None:
        """Remove a node."""
    def add_node(self, node: Node) -> None:
        """Adds a node to the graph."""
    def remove_edge(self, edge: Edge) -> None:
        """Remove an edge from the graph."""
    def add_edge(self, edge: Edge) -> None:
        """Adds an edge to the graph."""
    def copy(self) -> Graph: ...
    def crop(self, roi: Roi) -> Graph:
        """Remove all nodes from self that are not contained in `roi` except for
        "dangling" nodes."""
    def shift(self, offset: Union[int, np.ndarray]) -> None: ...
    def new_graph(self) -> nx.Graph: ...
    def trim(self, roi: Roi) -> Graph:
        """Create a copy of self and replace "dangling" nodes with contained nodes."""
    def _handle_boundaries(
        self,
        crossing_edges: Iterator[Edge],
        contained_nodes: Set[int],
        roi: Roi,
        node_id: Iterator[int],
    ): ...
    def _roi_intercept(
        self, inside: np.ndarray, outside: np.ndarray, bb: Roi
    ) -> np.ndarray:
        """Given two points, one inside a bounding box and one outside,
        get the intercept between the line and the bounding box.
        """
    def merge(
        self, other: Graph, copy_from_self: bool = False, copy: bool = False
    ) -> NoReturn:
        """Merge this graph with another. The resulting graph will have the Roi
        of the larger one.

        Do not use.
        """
    def to_nx_graph(self) -> nx.Graph:
        """Return a pure networkx graph containing data from this Graph."""
    @classmethod
    def from_nx_graph(cls, graph: nx.Graph, spec: GraphSpec) -> Graph:
        """Create a gunpowder graph from a networkx graph"""
        ...
    def relabel_connected_components(self) -> None:
        """create a new attribute "component" for each node in this Graph"""
    @property
    def connected_components(self) -> Iterator[set]: ...
    def in_degree(self) -> int: ...
    def successors(self, node: Node) -> Iterator: ...
    def predecessors(self, node) -> Iterator: ...

class GraphKey(Freezable):
    """A key to identify graphs in requests, batches, and across nodes."""

    identifier: str
    hash: int

    def __init__(self, identifier: str) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...

class GraphKeys:
    """Convenience access to all created :class:``GraphKey``s."""

    def __getattribute__(self, name: str) -> GraphKey: ...
